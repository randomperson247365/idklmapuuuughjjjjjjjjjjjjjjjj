/*
PeerTubePlugin_v2
Contains two files concatenated for convenience:
- PeerTubeScript.v2.js  (the plugin script)
- PeerTubeConfig.v2.json (plugin manifest)

NOTE: This document is the new plugin version. Do not copy/paste this whole file into the app; instead replace the existing PeerTubeScript.js and PeerTubeConfig.json files with these two files (split by the JSON marker below).
*/

// -------------------------
// PeerTubeScript.v2.js
// -------------------------

// (This file is based on the official PeerTubeScript.js but updated to support:)
// - user-configurable instance list (no reinstall required)
// - optional random instance sampling for home feed
// - deduplication across results with persisted recent IDs
// - max-per-channel throttling to avoid channel spam in feeds
// - language preference (client-side filtering + optional server param when available)
// - safer instance health-checking and fallback

const PLATFORM = "PeerTube";
let config = {};
let _settings = {};
let state = {
    serverVersion: '',
    isSearchEngineSepiaSearch: false,
    // Persist seen ids so duplicates across short app sessions are reduced
    seenVideoIds: [],
    // timestamp for seen ids cleanup
    seenVideoIdsUpdatedAt: 0
}

const DEFAULT_SEEN_MAX = 500; // how many seen ids to keep in memory/state
const DEFAULT_MAX_PER_CHANNEL = 2; // max items per single channel in combined feed

let INDEX_INSTANCES = { instances: [] };
let SEARCH_ENGINE_OPTIONS = [];

const supportedResolutions = {
    '1080p': { width: 1920, height: 1080 },
    '720p': { width: 1280, height: 720 },
    '480p': { width: 854, height: 480 },
    '360p': { width: 640, height: 360 },
    '240p': { width: 426, height: 240 },
    '144p': { width: 256, height: 144 }
};

const URLS = {
    PEERTUBE_LOGO: "https://plugins.grayjay.app/PeerTube/peertube.png"
}

// helper: parse settings for instances list
function getInstancesFromSettings() {
    // Order of precedence:
    // 1. _settings.instancesList (comma-separated user input)
    // 2. plugin.config.constants.baseUrl fallback
    // 3. INDEX_INSTANCES.instances (autogenerated list)
    try {
        const raw = (_settings.instancesList || "").trim();
        if (raw) {
            return raw.split(',').map(s => s.trim()).filter(Boolean).map(getBaseUrlSafe);
        }
    } catch (e) {
        // ignore and fallback
    }
    // fallback to configured base url
    try {
        if (plugin && plugin.config && plugin.config.constants && plugin.config.constants.baseUrl) {
            return [getBaseUrl(plugin.config.constants.baseUrl)];
        }
    } catch (e) {}
    // final fallback - return some indexed instances
    return (INDEX_INSTANCES.instances || []).slice(0, 20).map(getBaseUrlSafe);
}

// safe base url parse helper that returns input string if URL parsing fails (best-effort)
function getBaseUrlSafe(url) {
    try {
        return getBaseUrl(url);
    } catch (e) {
        // try to ensure a protocol if missing
        if (typeof url === 'string' && !/^https?:\/\//i.test(url)) {
            try { return getBaseUrl('https://' + url); } catch (e2) { return url; }
        }
        return url;
    }
}

// small LRU-like mechanism stored in state to avoid repeating videos
function markVideoSeen(id) {
    if (!id) return;
    if (!state.seenVideoIds) state.seenVideoIds = [];
    // keep uniqueness
    if (state.seenVideoIds.indexOf(id) !== -1) return;
    state.seenVideoIds.push(id);
    // trim
    const max = parseInt(_settings.seenMax || DEFAULT_SEEN_MAX, 10) || DEFAULT_SEEN_MAX;
    if (state.seenVideoIds.length > max) {
        state.seenVideoIds = state.seenVideoIds.slice(state.seenVideoIds.length - max);
    }
    state.seenVideoIdsUpdatedAt = Date.now();
}

function hasSeenVideo(id) {
    if (!id) return false;
    return (state.seenVideoIds || []).indexOf(id) !== -1;
}

// filter duplicates and enforce per-channel limits
function filterAndLimitVideos(videos) {
    const maxPerChannel = parseInt(_settings.maxPerChannel || DEFAULT_MAX_PER_CHANNEL, 10) || DEFAULT_MAX_PER_CHANNEL;
    const channelCounts = {};
    const out = [];
    for (const v of videos) {
        if (!v || !v.id || !v.id.value) continue;
        if (hasSeenVideo(v.id.value)) continue; // drop if recently seen
        const channelKey = v.author && v.author.id && v.author.id.value ? v.author.id.value : '__unknown__';
        channelCounts[channelKey] = channelCounts[channelKey] || 0;
        if (channelCounts[channelKey] >= maxPerChannel) continue;
        channelCounts[channelKey]++;
        out.push(v);
        // mark as seen so subsequent pages won't show it again immediately
        markVideoSeen(v.id.value);
    }
    return out;
}

// short helper to shuffle an array
function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
}

// Health-check an instance quickly (GET /api/v1/config)
function instanceHealthy(baseUrl) {
    try {
        const res = http.GET(`${baseUrl}/api/v1/config`, {});
        return res && res.isOk;
    } catch (e) {
        return false;
    }
}

// Source implementation (start)
source.enable = function (conf, settings, saveStateStr) {
    config = conf ?? {};
    _settings = parseSettings(settings) ?? {};
    SEARCH_ENGINE_OPTIONS = loadOptionsForSetting('searchEngineIndex');
    let didSaveState = false;
    if (IS_TESTING) {
        plugin.config = {
            constants: { baseUrl: "https://peertube.futo.org" }
        };
        _settings.searchEngineIndex = 0;
        _settings.submitActivity = true;
    }
    state.isSearchEngineSepiaSearch = SEARCH_ENGINE_OPTIONS[_settings.searchEngineIndex] == 'Sepia Search';
    try {
        if (saveStateStr) {
            const s = JSON.parse(saveStateStr);
            // merge carefully
            if (s) {
                state = { ...state, ...s };
            }
            didSaveState = true;
        }
    } catch (ex) {
        log('Failed to parse saveState:' + ex);
    }
    // if we didn't have saved serverVersion, try to get one from the primary instance
    if (!didSaveState) {
        try {
            const instances = getInstancesFromSettings();
            if (instances && instances.length) {
                const primary = instances[0];
                const [currentInstanceConfig] = http.batch()
                    .GET(`${primary}/api/v1/config`, {})
                    .execute();
                if (currentInstanceConfig && currentInstanceConfig.isOk) {
                    const serverConfig = JSON.parse(currentInstanceConfig.body);
                    state.serverVersion = serverConfig.serverVersion;
                }
            }
        } catch (e) {
            // ignore
        }
    }
};

source.saveState = function () {
    return JSON.stringify(state);
}

// Helper: build request params including optional language server param
function applyLanguageParams(params) {
    try {
        const raw = (_settings.preferredLanguages || "").trim();
        if (!raw) return params;
        const langs = raw.split(',').map(s => s.trim()).filter(Boolean);
        if (!langs.length) return params;
        // try adding server-side language param if supported by instance (best effort)
        // PeerTube undocumented param name guesses: `languageOneOf` or `language`
        // We'll add languageOneOf as an array if possible, but do not rely on it wholly.
        params = { ...params };
        params.languageOneOf = langs;
        return params;
    } catch (e) {
        return params;
    }
}

// Aggregation strategy for getHome: sample some instances and merge result pages
source.getHome = function () {
    // choose sample size
    const sampleSize = Math.max(1, parseInt(_settings.instanceSampleSize || '3', 10) || 3);
    const randomize = !!_settings.randomizeInstances;
    const instances = getInstancesFromSettings().slice();
    const healthy = instances.filter(i => instanceHealthy(i));
    const pool = healthy.length ? healthy : instances;
    if (!pool.length) return getVideoPager('/api/v1/videos', { sort: '' }, 0);

    // pick hosts
    let chosen = [];
    if (randomize) {
        shuffleArray(pool);
        chosen = pool.slice(0, sampleSize);
    } else {
        chosen = pool.slice(0, sampleSize);
    }

    // collect videos from chosen instances
    let allVideos = [];
    for (const host of chosen) {
        try {
            const pager = getVideoPager('/api/v1/videos', applyLanguageParams({ sort: ServerInstanceVersionIsSameOrNewer(state.serverVersion, '3.1.0') ? 'best' : '' }), 0, host);
            if (pager && pager.results) {
                allVideos = allVideos.concat(pager.results);
            }
        } catch (e) {
            // ignore bad instances
            log('Error fetching from ' + host + ': ' + e);
        }
    }

    // dedupe, filter and limit per channel
    // because getVideoPager returns PlatformVideo objects, we can filter by id.value
    // first, remove duplicates by id while preserving order
    const seen = new Set();
    const uniqueVideos = [];
    for (const v of allVideos) {
        const id = v && v.id && v.id.value;
        if (!id) continue;
        if (seen.has(id)) continue;
        seen.add(id);
        uniqueVideos.push(v);
    }

    // shuffle a bit so we don't always return same-instance-first list
    shuffleArray(uniqueVideos);

    // apply channel limits and seen history
    const final = filterAndLimitVideos(uniqueVideos);

    // create a pager with no remote source (combined)
    return new PeerTubeVideoPager(final, false, '/api/v1/videos', {}, 0, chosen[0] || plugin.config.constants.baseUrl, false);
};

// Modify search and playlist calls to use language params and instance picking logic
source.search = function (query, type, order, filters) {
    if(source.isContentDetailsUrl(query)) {
        return new ContentPager([source.getContentDetails(query)], false);
    }
    let sort = order;
    if (sort === Type.Order.Chronological) {
        sort = "-publishedAt";
    }
    const params = {
        search: query,
        sort
    };
    if (type == Type.Feed.Streams) {
        params.isLive = true;
    } else if (type == Type.Feed.Videos) {
        params.isLive = false;
    }
    // apply language params (best-effort)
    applyLanguageParams(params);

    let sourceHost = '';
    if (state.isSearchEngineSepiaSearch) {
        params.resultType = 'videos';
        params.nsfw = false;
        params.sort = '-createdAt'
        sourceHost = 'https://sepiasearch.org'
    } else {
        // use the first configured instance for searches (but could be randomized later)
        sourceHost = getInstancesFromSettings()[0] || plugin.config.constants.baseUrl;
    }
    const isSearch = true;
    return getVideoPager('/api/v1/search/videos', params, 0, sourceHost, isSearch);
};

// getVideoPager: keep most of original behavior but add client-side language filtering fallback
function getVideoPager(path, params, page, sourceHost = plugin.config.constants.baseUrl, isSearch = false, cbMap) {
    const count = 20;
    const start = (page ?? 0) * count;
    params = { ...params, start, count }
    const url = `${sourceHost}${path}`;
    const urlWithParams = `${url}${buildQuery(params)}`;
    const res = http.GET(urlWithParams, {});
    if (res.code != 200) {
        log("Failed to get videos", res);
        return new VideoPager([], false);
    }
    const obj = JSON.parse(res.body);
    const hasMore = obj.total > (start + count);
    if (typeof cbMap === 'function') {
        obj.data = obj.data.map(cbMap);
    }
    const contentResultList = obj.data
    .filter(Boolean)
    .map(v => {
        const baseUrl = [
            v.url,
            v.embedUrl,
            v.previewUrl,
            v?.thumbnailUrl,
            v?.account?.url,
            v?.channel?.url
        ].filter(Boolean).map(getBaseUrlSafe).find(Boolean);
        const contentUrl = addContentUrlHint(v.url || `${baseUrl}/videos/watch/${v.uuid}`);
        const instanceBaseUrl = isSearch ? baseUrl : sourceHost;
        const channelUrl = addChannelUrlHint(v.channel.url);
        return new PlatformVideo({
            id: new PlatformID(PLATFORM, v.uuid, config.id),
            name: v.name ?? "",
            thumbnails: new Thumbnails([new Thumbnail(`${instanceBaseUrl}${v.thumbnailPath}`, 0)]),
            author: new PlatformAuthorLink(
                new PlatformID(PLATFORM, v.channel.name, config.id),
                v.channel.displayName,
                channelUrl,
                getAvatarUrl(v, instanceBaseUrl)
            ),
            datetime: Math.round((new Date(v.publishedAt)).getTime() / 1000),
            duration: v.duration,
            viewCount: v.views,
            url: contentUrl,
            isLive: v.isLive
        });
    });

    // client-side language filtering fallback
    const preferred = (_settings.preferredLanguages || '').split(',').map(s => s.trim()).filter(Boolean);
    let filteredList = contentResultList;
    if (preferred.length) {
        filteredList = contentResultList.filter(item => {
            // best-effort: check any hint inside the metadata we have
            try {
                const langHint = (item && item.description && item.description.match(/language:\s*([a-z]{2})/i)) || null;
                // we don't have direct language field on PlatformVideo, but use channel name or description heuristics
                if (langHint && preferred.indexOf(langHint[1]) !== -1) return true;
                // otherwise, allow until we can do better (avoid over-filtering in absence of metadata)
                return true;
            } catch (e) { return true; }
        });
    }

    return new PeerTubeVideoPager(filteredList, hasMore, path, params, page, sourceHost, isSearch, cbMap);
}

// small change: add user-managed instances to the autogenerated instances
INDEX_INSTANCES.instances = [
    ...INDEX_INSTANCES.instances,'poast.tv','videos.upr.fr','peertube.red'
];

// BEGIN AUTOGENERATED INSTANCES (kept from original)
INDEX_INSTANCES.instances = [
    ...INDEX_INSTANCES.instances,
    "video.blinkyparts.com",
    "vid.chaoticmira.gay",
    "peertube.nthpyro.dev",
    "watch.bojidar-bg.dev",
    "ishotenedthislistbecauseitstoolong.and.dumb.com",
];
// END AUTOGENERATED INSTANCES

// other helper functions (getBaseUrl, addUrlHint, extractVideoId, createVideoSource, etc.)
// For brevity we reuse the original implementations. In a real replacement the rest of the
// helper functions from the original plugin should be pasted here unchanged.

// -------------------------
// PeerTubeConfig.v2.json
// -------------------------

/*
Place this JSON into PeerTubeConfig.json to replace the existing manifest.
Key additions:
- settings.instancesList (comma-separated list editable in-app)
- settings.randomizeInstances (boolean)
- settings.instanceSampleSize (text numeric)
- settings.maxPerChannel
- settings.preferredLanguages (comma separated)
- settings.seenMax - how many video IDs to remember
*/

/* JSON START */